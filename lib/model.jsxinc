// lib/model.jsxinc
// Core Logic: Scanning and Organizing
// Asset Assassin: Hybrid Import Pro v3.2

var Model = (function () {

    function getOrCreateFolder(path, root) {
        // If root is provided, create relative to root. Otherwise absolute from project root.
        var current = root ? root : app.project.rootFolder;
        var parts = path.split("/");

        for (var i = 0; i < parts.length; i++) {
            var folderName = parts[i];
            if (folderName === "") continue;

            var found = null;
            for (var k = 1; k <= current.numItems; k++) {
                var item = current.item(k);
                if (item instanceof FolderItem && item.name === folderName) {
                    found = item;
                    break;
                }
            }

            if (found) current = found;
            else current = current.items.addFolder(folderName);
        }
        return current;
    }

    function getUniqueName(name, folder) {
        var newName = name;
        var inc = 1;
        while (nameExists(newName, folder)) {
            var parts = name.lastIndexOf(".") > 0 ? name.split(".") : [name];
            var ext = parts.length > 1 ? "." + parts.pop() : "";
            newName = parts.join(".") + "_" + inc + ext;
            inc++;
        }
        return newName;
    }

    function nameExists(name, folder) {
        for (var i = 1; i <= folder.numItems; i++) {
            if (folder.item(i).name === name) return true;
        }
        return false;
    }

    function scan(rootFolder) {
        var results = { comps: [], solids: [], ren: [], footage: [], ill: [], images: [], psd: [], audio: [], others: [] };

        function recursiveScan(folder) {
            for (var i = 1; i <= folder.numItems; i++) {
                var item = folder.item(i);
                if (item instanceof FolderItem) {
                    recursiveScan(item);
                } else if (item instanceof CompItem) {
                    results.comps.push(item);
                } else if (item instanceof FootageItem) {
                    if (item.mainSource instanceof SolidSource) {
                        results.solids.push(item);
                    } else if (item.file) {
                        var ext = item.file.name.split('.').pop().toLowerCase();
                        var matched = false;

                        // Check against Config
                        for (var type in Config.FILE_TYPES) {
                            if (type === 'solids') continue; // Skip solids, handled above
                            var typeDef = Config.FILE_TYPES[type];
                            for (var e = 0; e < typeDef.exts.length; e++) {
                                if (ext === typeDef.exts[e].toLowerCase()) {
                                    results[type].push(item);
                                    matched = true;
                                    break;
                                }
                            }
                            if (matched) break;
                        }

                        if (!matched) results.others.push(item);
                    }
                }
            }
        }
        recursiveScan(rootFolder);
        return results;
    }

    function process(scanResults, settings, rootFolder, progressCallback) {
        var stats = {
            moved: 0,
            flattened: 0,
            cleaned: 0,
            errors: 0,
            details: [] // For summary
        };

        var isDryRun = settings.dryRun;

        // Helper to "move"
        function moveItems(itemList, targetPath, typeLabel) {
            if (itemList.length === 0) return;

            var destFolder = null;
            if (!isDryRun) {
                destFolder = getOrCreateFolder(targetPath, null); // Global move
            }

            for (var i = 0; i < itemList.length; i++) {
                var item = itemList[i];

                if (isDryRun) {
                    stats.details.push("[DRY RUN] Would move '" + item.name + "' -> " + targetPath);
                } else {
                    try {
                        item.parentFolder = destFolder;
                        item.name = getUniqueName(item.name, destFolder);
                    } catch (e) {
                        stats.errors++;
                        stats.details.push("[ERROR] Failed to move '" + item.name + "': " + e.toString());
                    }
                }
                stats.moved++;
                if (progressCallback) progressCallback();
            }
        }

        // Helper to flatten comps
        function flattenComps(itemList) {
            if (itemList.length === 0) return;

            var preCompFolder = null;

            for (var i = 0; i < itemList.length; i++) {
                var item = itemList[i];
                var destFolder;
                var targetName = "Root";

                if (item.name.match(/^pre[-_]?/i)) {
                    targetName = "Pre-Comps";
                    if (!isDryRun) {
                        if (!preCompFolder) preCompFolder = getOrCreateFolder("pre-comps", rootFolder);
                        destFolder = preCompFolder;
                    }
                } else {
                    if (!isDryRun) destFolder = rootFolder;
                }

                if (isDryRun) {
                    stats.details.push("[DRY RUN] Would flatten Comp '" + item.name + "' -> " + targetName);
                } else {
                    if (item.parentFolder.id !== destFolder.id) {
                        item.name = getUniqueName(item.name, destFolder);
                        item.parentFolder = destFolder;
                    }
                }
                stats.flattened++;
                if (progressCallback) progressCallback();
            }
        }

        // Execute based on settings
        if (settings.ren) moveItems(scanResults.ren, Config.FILE_TYPES.ren.target, "3D");
        if (settings.footage) moveItems(scanResults.footage, Config.FILE_TYPES.footage.target, "Footage");
        if (settings.ill) moveItems(scanResults.ill, Config.FILE_TYPES.ill.target, "Vector");
        if (settings.images) moveItems(scanResults.images, Config.FILE_TYPES.images.target, "Images");
        if (settings.psd) moveItems(scanResults.psd, Config.FILE_TYPES.psd.target, "PSD");
        if (settings.audio) moveItems(scanResults.audio, Config.FILE_TYPES.audio.target, "Audio");
        if (settings.solids) moveItems(scanResults.solids, Config.FILE_TYPES.solids.target, "Solids");
        if (settings.comps) flattenComps(scanResults.comps);

        // Prune
        if (settings.prune) {
            if (isDryRun) {
                stats.details.push("[DRY RUN] Would delete empty folders in selection.");
                // Cannot easily count strictly in dry run without simulating the whole tree structure change
            } else {
                var pruneCount = 0;
                var pruneFunc = function (folder) {
                    if (folder.numItems > 0) {
                        for (var i = folder.numItems; i >= 1; i--) {
                            var item = folder.item(i);
                            if (item instanceof FolderItem) pruneFunc(item);
                        }
                    }
                    if (folder.numItems === 0 && folder.id !== rootFolder.id) {
                        folder.remove();
                        pruneCount++;
                    }
                };
                pruneFunc(rootFolder);
                stats.cleaned = pruneCount;
            }
        }

        return stats;
    }

    return {
        scan: scan,
        process: process,
        processDryRun: function (scanResults, settings, rootFolder) {
            // Dry run logic is embedded in process via flag, cleaner than duplicating
            var dryRunSettings = {};
            for (var key in settings) dryRunSettings[key] = settings[key];
            dryRunSettings.dryRun = true;
            return process(scanResults, dryRunSettings, rootFolder, null);
        }
    };

})();
